# Discovery Log

Chronological, append-only record of how memory-system ideas evolved.

## Update Rule

When a new memory-design idea is discussed:
- First append raw notes to `00-lab/immutable-work-log.md`.
- Then append a distilled dated entry to `discovery.md` with:
- What changed.
- Why it changed.
- Which files were updated.
- What remains open.

## 2026-02-14 - Foundation Baseline

Conversation established the baseline architecture captured in:
- `01-foundation/summary.md`
- `01-foundation/architecture-insights.md`
- `01-foundation/memory-ontology.md`
- `01-foundation/memory-creation-and-categorization.md`
- `01-foundation/storage-layer.md`

Key outcomes:
- Interface boundary set to `read`, `write`, `dispute`.
- Scope simplified to repo + global only (no domain layer).
- Retrieval pipeline set to scope -> relevance -> association -> threshold -> selection.
- Storage anchored on SQLite with immutable event log authority and rebuildable projections.
- Principle set to precision over recall, including "empty is correct" when confidence is low.

## 2026-02-18 - Outside-In Breakthrough Pass

Raw ideation captured in:
- `02-breakthrough/breakthrough-raw.md`

Structured reformulation captured in:
- `02-breakthrough/breakthrough-structured.md`

Key developments:
- Retrieval clarified as two-lane recall: semantic association lane + bounded keyword lane, then dedupe/merge.
- Strong emphasis that codebase state is immediate ground truth and memory is advisory utility.
- Session-end write flow clarified with duplicate checks, contradiction handling, and optional autonomous storage mode.
- Problem-solution linkage became explicit: retrieval and expansion operate over linked memories.

## 2026-02-18 - Failed Tactics Promoted To First-Class Memory

Design extension incorporated into structured and core docs:
- `02-breakthrough/breakthrough-raw.md`
- `02-breakthrough/breakthrough-structured.md`
- `01-foundation/architecture-insights.md`
- `01-foundation/memory-ontology.md`
- `01-foundation/memory-creation-and-categorization.md`
- `01-foundation/storage-layer.md`
- `01-foundation/summary.md`

Key developments:
- Failed attempts are no longer implicit only in episode text.
- Experiential memory is now modeled as linked `problems`, `solutions`, and `failed_tactics`.
- Immutable episode logs remain evidence, while normalized linked records power retrieval.

## 2026-02-18 - Utility vs Truth Framing (User Verbatim Points)

Verbatim source notes recorded in:
- `03-refinements/user-three-points-verbatim.md`

Synthesis of the three-point direction:
- Distinguish instantaneous truth (current code state) from historical memory utility.
- Track memory usefulness relative to specific problem contexts, not only global vote totals.
- Treat changes in utility and changes in truth as separable update streams over immutable history.

## 2026-02-18 - Policy Concretization: Overfitting, Weak Priors, and Chain Classes

Detail note added:
- `03-refinements/policy-overfitting-bayesian-chains.md`

What changed:
- Adopted a concrete policy against stale-memory overfitting: memory is optional utility, and current workspace/code observation is the instantaneous truth source.
- Confirmed global utility can exist as a weak prior and is best treated as computed-after-the-fact rather than primary.
- Recognized a shared Bayesian flavor between utility and truth updates:
  - utility as a belief updated by context-specific outcomes,
  - truth as a belief in `[0,1]` updated by supporting/contradicting evidence.
- Clarified "chain idea" now has two distinct forms:
  - implicit association chain via semantic/vector similarity,
  - explicit association chain via formal deterministic links (for example, base memory -> update memories).

Why it changed:
- To keep the system aligned with optionality and avoid rigid deterministic handling that drifts from the original design intent.
- To preserve immutable history while still enabling "what is useful now" and "what is likely true now" behavior.

What remains open:
- Whether to formally implement Bayesian update math or keep the same concept with lightweight heuristics.
- Exact weighting mechanics for weak global priors vs problem-specific evidence.
- Prompt wording and retrieval behavior that enforce explicit-association traversal without over-constraining exploration.

## 2026-02-18 - Dogfooding Workflow: Raw Log + Discovery Abstraction

What changed:
- Added a dedicated immutable raw-note log: `00-lab/immutable-work-log.md`.
- Clarified that `discovery.md` is an abstraction/extraction layer over raw notes.
- Updated structure guidance so agents should record notes automatically, without waiting for explicit prompts.

Why it changed:
- To dogfood the memory design process while designing it.
- To preserve intermediate reasoning and dead ends, not only polished summaries.

What remains open:
- Cadence for abstraction from raw log into discovery (every significant turn vs milestone-only).

## 2026-02-18 - Provisional Decision: Heuristics First, Bayesian-Compatible Later

What changed:
- Set abstraction cadence: raw log updates every ideation turn; discovery updates when there is a decision, policy shift, or a coherent new open-question cluster.
- Took a provisional stance on update mechanics: lightweight heuristics first for truth/utility updates, with Bayesian compatibility preserved for later.

Why it changed:
- Current evidence volume is low, so full Bayesian machinery now risks complexity before signal quality justifies it.
- A heuristic-first path keeps momentum while still preserving the conceptual Bayesian framing already recognized in this project.

What remains open:
- Graduation criteria from heuristic to Bayesian updates (for example, observation count, calibration error, or drift frequency thresholds).
- Exact heuristic forms for truth update and utility update in v1.

## 2026-02-18 - Ratified Direction: JSON Contracts and Evidence Strictness Split

What changed:
- Ratified interface direction: use a clean scoped memory API/tool surface with JSON request/response contracts.
- Ratified evidence policy split:
  - truth updates require supporting evidence references,
  - utility updates allow optional evidence.
- Ratified update style: keep lightweight heuristic updates in `[0,1]` now, while preserving a path to Bayesian formalization later.

Why it changed:
- JSON contracts improve reliability for LLM interaction without over-constraining reasoning behavior.
- Strict truth evidence protects against drift; optional utility evidence avoids heavy attribution overhead in low-friction workflows.
- Heuristic-first keeps momentum during ideation and low-volume operation.

What remains open:
- Exact scoped API verbs and payload fields.
- Fallback behavior when utility updates have no evidence (for example, smaller deltas or deferred persistence).
- Concrete v1 heuristic update function details.

## 2026-02-18 - Ratified Interface Semantics: `read`, `write`, `update` + Validation Layer

What changed:
- Ratified interface operation split:
  - `read`: retrieval only.
  - `write`: creates immutable memory records.
  - `update`: adjusts dynamic values on existing memory IDs (`truth`, `utility`) in `[0,1]`.
- Ratified interpretation for "update memories":
  - Statements like "X changed in the codebase and invalidates Y" are new memories and therefore use `write` (kind `change`), not `update`.
- Ratified memory kind set for v1 interface contracts:
  - `problem`, `solution`, `failed_tactic`, `fact`, `preference`, `change`.
- Ratified categorization rule:
  - The writing agent provides explicit `scope` and `kind` (no ambiguous `auto` categorization in payloads).
- Ratified validation placement:
  - A validation layer sits directly under the interface.
  - It performs schema validation (JSON shape/types/required fields) and semantic validation (domain rules such as evidence requirements).

Why it changed:
- This split resolves ambiguity between immutable memory creation and mutable value adjustment.
- It preserves append-only memory history while still allowing current utility/truth projections to evolve.
- It makes agent behavior parseable and auditable without over-constraining reasoning.

What remains open:
- Exact canonical JSON payload definitions and required-field matrix by operation.
- Final semantic validation rules by memory kind (for example, required links for `solution` and `failed_tactic`).

## 2026-02-18 - Ratified Card: Exact JSON Schemas for `read` / `write` / `update`

Card added:
- `04-contracts/memory-interface-json-schemas-v1.md`

What changed:
- Recorded the exact approved JSON schemas verbatim for:
  - `memory.read.request`
  - `memory.write.request`
  - `memory.update.request`
- Confirmed operation semantics in the card:
  - `write` creates immutable memories,
  - `update` adjusts dynamic values,
  - \"update memory\" statements are `write` with `kind: change`.
- Confirmed validation placement directly under the interface (schema + semantic validation).

Why it changed:
- To make the interface concrete and implementation-ready without ambiguity.
- To preserve the approved contract in a single source-of-truth card that discovery can link to.

What remains open:
- Final semantic validation matrix by kind/field requirement (especially linking requirements and edge-case rules).

## 2026-02-18 - Retrospective Gap Fill: Lightweight Update Policy + Late Interface Clarifications

Card added:
- `03-refinements/lightweight-update-policy-and-interface-clarifications.md`

What changed:
- Captured the ratified anti-rigidity principle explicitly: avoid fixed update taxonomies and keep reasoning freeform while contracts stay minimal.
- Captured the ratified lightweight update shape explicitly: dynamic `truth` and `utility` in `[0,1]`, confidence/rationale/refs at reflection time, bounded deterministic adjustment (not pure intuition).
- Captured attribution reality for utility updates: optional evidence is acceptable, with weaker/deferred impact when evidence is missing.
- Captured late interface clarifications in one place:
  - single `update` op with `mode: "dry_run" | "commit"` rather than separate `propose_update`/`apply_update`,
  - explicit `scope` + `kind` in `write` (no `auto`),
  - `read.kinds` as include filter.

Why it changed:
- These points were discussed and approved in the thread but were spread across transcript turns and not represented as a dedicated refinement note.

What remains open:
- Exact numerical update-function parameters (caps/damping/skip thresholds).
- Final fallback policy for utility updates with no evidence (small delta vs defer).

## 2026-02-18 - Ratified Card: Concrete Relational Storage Schema v1 (No Truth Score)

Card added:
- `04-contracts/memory-storage-relational-schema-v1.md`

What changed:
- Ratified relational (SQLite) storage for v1, with graph semantics represented through explicit link tables rather than a graph database.
- Ratified top-level memory kinds as stored immutable records:
  - `problem`, `solution`, `failed_tactic`, `fact`, `preference`, `change`.
- Ratified direct experiential linkage with:
  - `problem_attempts(problem_id, attempt_id, role)` where role is `solution` or `failed_tactic`.
- Ratified fact-change modeling as immutable chain links:
  - `old_fact_id + change_id -> new_fact_id` via `fact_updates`.
- Ratified current-fact representation as a derived snapshot view:
  - `current_fact_snapshot`.
- Ratified utility storage as contextual observations:
  - `utility_observations(memory_id, problem_id, vote in [-1,1])`.
- Ratified removal of mutable truth/accuracy score in v1.

Why it changed:
- To make data storage as concrete as the already-approved interface schemas.
- To preserve provenance and append-only history while keeping the model simple and implementation-ready.
- To avoid premature complexity from truth-scoring machinery when fact updates already encode truth evolution explicitly.

What remains open:
- Whether scenario-level metadata should reintroduce a scenario container later.
- Whether semantic invariants should also be enforced with DB triggers in addition to interface semantic validation.

## 2026-02-19 - Ratified Naming Split: Interface Verbs vs Policy Layers

What changed:
- Ratified policy-layer names:
  - `Read Policy` for retrieval behavior.
  - `Write Policy` for create/update acceptance, validation, and DB side effects.
- Ratified interface-verb framing:
  - `create`, `read`, `update` as the conceptual external verbs.
- Ratified routing between layers:
  - `read` routes to Read Policy.
  - `create` and `update` route to Write Policy.
- Ratified that `update` remains a distinct interface verb (rather than collapsing everything into create/write), even though it is write-path behavior internally.

Why it changed:
- To reduce naming ambiguity between policy and API layers.
- To keep the interface clear for agents while preserving a strict internal write-path rule system.
- To avoid turning create/write into a catch-all operation with overloaded semantics.

Files updated:
- `insights/00-lab/immutable-work-log.md`
- `insights/discovery.md`

What remains open:
- Whether to rename wire-level `op: "write"` to `op: "create"` in the interface contract, or support `create/write` aliasing for a migration window.

## 2026-02-19 - Ratified Write Policy v1 (Create/Update Determinism)

What changed:
- Ratified policy routing:
  - `read` -> Read Policy.
  - `create` and `update` -> Write Policy.
- Ratified role split:
  - LLM provides judgment and intent (`kind`, `scope`, statement text, links, evidence refs).
  - Write Policy performs deterministic acceptance/rejection and DB side effects.
- Ratified ordered validity gates for write-path operations:
  - schema validity,
  - semantic write-policy validity,
  - DB integrity validity.
- Ratified atomicity:
  - accepted create/update requests execute in one transaction;
  - any failure aborts all side effects.
- Ratified strict evidence requirement for create in v1:
  - `evidence_refs >= 1` for all create kinds (`problem`, `solution`, `failed_tactic`, `fact`, `preference`, `change`).
  - for preferences, evidence may be user-message/session references (not necessarily code references).
- Ratified deterministic side-effect mapping:
  - `create(problem|fact|preference|change)` -> `memories` (+ evidence link rows),
  - `create(solution|failed_tactic)` -> `memories` + `problem_attempts` (+ evidence link rows),
  - `update(archive_state)` -> `memories.archived`,
  - `update(utility_vote)` -> `utility_observations`,
  - `update(fact_update_link)` -> `fact_updates` (with kind checks).

Why it changed:
- To close the implementation gap between schema definitions and executable behavior.
- To make write-path behavior unambiguous and auditable for implementers.
- To preserve LLM judgment while enforcing deterministic storage rules.

Files updated:
- `insights/00-lab/immutable-work-log.md`
- `insights/discovery.md`

What remains open:
- Concrete episodic ongoing log contract for source content storage (the target that `evidence_refs.ref` points to).
- Canonical `evidence_ref` pointer format for episode/user/tool/file spans.
- Whether wire-level `op: "write"` should be renamed to `op: "create"` or aliased during migration.

## 2026-02-19 - Ratified Episodic Log Direction v1 (Single Source + Minimal Event Model)

What changed:
- Ratified episodic storage authority:
  - SQLite episodic tables are canonical.
  - Any append-only text log is optional export only (non-authoritative).
- Ratified minimal episodic schema direction:
  - `episodes(id, repo_id, started_at, ended_at)`
  - `episode_events(id, episode_id, seq, content, created_at)`
- Ratified event granularity:
  - one row per individual message/tool call,
  - not one row per full turn blob.
- Ratified v1 evidence targeting:
  - `evidence_refs.ref` points to whole event IDs (`episode_event_id`).
  - span-level pointers (`event_id:start:end`) are deferred.
- Ratified write-path ergonomics:
  - runtime auto-captures episodic events,
  - LLM references generated event IDs in `evidence_refs` during create/update operations.

Why it changed:
- To eliminate dual-source drift between DB and ad-hoc append logs.
- To keep evidence links stable, auditable, and easy to dereference.
- To keep v1 schema minimal while preserving fine-grained evidence precision via per-event rows.

Files updated:
- `insights/00-lab/immutable-work-log.md`
- `insights/discovery.md`

What remains open:
- Canonical payload format for `episode_events.content` in v1.
- Canonical string format for `evidence_refs.ref` (for example, `event:<id>` vs plain `<id>`).
- Whether any minimal event metadata should be mandatory in `content` (for example, source role or tool name) without introducing rigid event-type enums.
